\chapter*{Marco teórico}
El desarrollo de software en la actualidad se divide en dos metodologías principales, las metodologías tradicionales y las ágiles. En primer lugar, el proceso de desarrollo en una metodología tradicional se basa en técnicas predictivas, las cuales permiten estimar el alcance de un producto según sus requerimientos y el presupuesto asignado al mismo, por lo tanto todas las etapas del ciclo de vida del desarrollo deben ajustarse en gran medida al cronograma pactado al inicio del proyecto, estas etapas se describen a continuación \cite{Stoica2013}:
\begin{itemize}
	\item Análisis de requisitos: En este punto se analiza la necesidad del cliente con el fin de identificar la factibilidad económica, técnica y operacional del proyecto.
	\item Definición de requisitos: Luego de ser analizados, los requisitos deben ser debidamente documentados y aprobados por el cliente para ser diseñados y desarrollados en posteriores etapas del ciclo de vida del proyecto.
	\item Diseño de la arquitectura del producto: Se desarrolla una propuesta arquitectónica para el desarrollo la cual debe ser aprobada por todas las partes interesadas, en esta propuesta se deben tener en cuenta aspectos como el riesgo, robustez del producto, presupuesto y restricciones de tiempo.
	\item Desarrollo del producto: En esta etapa se crea el código fuente del producto basado en los requisitos y estructurado según la arquitectura definida, además se debe cumplir con especificaciones de lenguaje y framework de programación a utilizar.
	\item Pruebas del producto: La funcionalidad del producto debe ser probada con el fin de identificar defectos para implementar su debida solución.
	\item Operación y mantenimiento: Una vez el producto es probado se procede a incluirlo en ambiente de producción y liberarlo al mercado.
\end{itemize}  
En metodologías tradicionales este ciclo de vida se desarrolla una única vez en todo el proyecto, entregando un producto terminado al cliente con todos los requisitos solicitados al inicio.\\

Por otro lado las metodologías tradicionales basan su filosofía en entregas continuas que generen valor al negocio del cliente por lo tanto todo el ciclo de vida del producto se realiza múltiples veces durante su desarrollo en los llamados Sprints con la finalidad de realizar los cambios necesarios en el momento oportuno, estos Sprints tienen una duración promedio de 2 a 4 semanas, al ser un periodo de tiempo tan corto en cada uno de ellos se desarrollan pocos requisitos del producto y se repite el ciclo de manera incremental hasta alcanzar un producto viable que pueda ser llevado a producción (Release), con el cual el cliente pueda generar retorno de inversión.\\

En el cuadro 1 se presenta una tabla comparativa entre metodologías de desarrollo tradicional y ágil.\\

\begin{table}[ht]
	\centering
	\caption{Metodologías tradicionales vs Ágiles}
	\label{tabla1}
\begin{tabular}{l|l|l|}
	\cline{2-3}
	& \multicolumn{1}{c|}{\textbf{Tradicional}}                                            & \multicolumn{1}{c|}{\textbf{Ágil}}                                                                      \\ \hline
	\multicolumn{1}{|l|}{\textbf{Principal objetivo}}        & Alta seguridad                                                                       & Valor rápido                                                                                            \\ \hline
	\multicolumn{1}{|l|}{\textbf{Modelo de desarrollo}}      & Modelo de ciclo de vida                                                              & Modelo evolutivo                                                                                        \\ \hline
	\multicolumn{1}{|l|}{\textbf{Control de calidad}}        & Dificil y pruebas tardías                                                            & \begin{tabular}[c]{@{}l@{}}Control permanente de los\\ requisitos y pruebas continuas\end{tabular}      \\ \hline
	\multicolumn{1}{|l|}{\textbf{Requisitos de usuario}}     & \begin{tabular}[c]{@{}l@{}}Detallados y definidos \\ antes de codificar\end{tabular} & Definición continua                                                                                     \\ \hline
	\multicolumn{1}{|l|}{\textbf{Costo de reinicio}}         & Alto                                                                                 & Bajo                                                                                                    \\ \hline
	\multicolumn{1}{|l|}{\textbf{Pruebas}}                   & \begin{tabular}[c]{@{}l@{}}Luego de que el codigo\\ este completo\end{tabular}       & En cada iteración                                                                                       \\ \hline
	\multicolumn{1}{|l|}{\textbf{Participación del cliente}} & Baja                                                                                 & Alta                                                                                                    \\ \hline
	\multicolumn{1}{|l|}{\textbf{Escala del proyecto}}       & Gran escala                                                                          & Todas las escalas                                                                                       \\ \hline
	\multicolumn{1}{|l|}{\textbf{Requisitos}}                & Muy estables                                                                         & Propensos al cambio                                                                                     \\ \hline
	\multicolumn{1}{|l|}{\textbf{Arquitectura}}              & \begin{tabular}[c]{@{}l@{}}Ajustada a los requisitos\\ iniciales\end{tabular}        & \begin{tabular}[c]{@{}l@{}}Diseñada para los requisitos\\ actuales pero propensa al cambio\end{tabular} \\ \hline
	\multicolumn{1}{|l|}{\textbf{Costo de remodelado}}       & Alto                                                                                 & Bajo                                                                                                    \\ \hline
\end{tabular}
\end{table}
Ahora, independiente de la metodogia con la que se aborde el desarrollo del producto, es necesario establecer herramientas que faciliten el ciclo de vida del desarrollo de software, para el caso de las dos primeras etapas del ciclo (Análisis de requisitos y Definición de requisitos) existen múltiples maneras de ser abordadas, en la actualidad suele utilizarse una metodología llamada Design Thinking ya que se incluye activamente al cliente dentro del proceso.\\

Design Thinkin es reconocido como un nuevo paradigma desde el año 2009 ya que se adaptó muy bien a la solución de problemas en diversos tipos de industrias, su éxito lo debe a la manera de abordar la concepción tanto del problema como su solución en donde modifica la formula que utiliza normalmente el raciocinio humano para encontrar una alternativa de solución. Normalmente el ser humano conoce muy bien el QUE se debería realizar y el  COMO debe hacerse, pero tiene total desconocimiento del valor o el resultado que le otorgará este proceso, por otro lado design thinking se centra en el valor que espera tener, luego de tener muy claro este valor se procede a definir la estrategia (o el COMO) se pretende obtener el resultado esperado y por ultimo se identifica el QUE o la solución especifica para cumplir con la meta \cite{Dorst2011}.\\

Si bien design thinking permite una definición clara y precisa del problema y la estrategia a abordar, es necesario validarla, para esto es conveniente utilizar un enfoque de doble diamante, el cual consta de  cuatro etapas que pretenden dar una idea prematura de la viabilidad de la solución tanto de manera técnica como de mercado \cite{Clune2014}.\\

El proceso de doble diamante comienza con una etapa de descubrimiento, en ésta se realiza una investigación tanto de mercado como de posibles usuarios con el objetivo de comprender si la posible solución encaja o no en algún sector del mercado haciendo el proyecto viable, en este punto es conveniente realizar encuestas o estudios de aceptación con posibles usuarios del producto. Posteriormente con la finalidad de cubrir las demás etapas del ciclo de vida del desarrollo  se pasa a una etapa de definición donde se alinean las necesidades encontradas en el sector de mercado con objetivos de negocio, luego se inicia la tapa de desarrollo en la cual se crean los elementos de software necesarios, siempre teniendo presentes las pruebas de software que aseguren la calidad del producto construido y por ultimo se lleva a cabo la etapa de liberación en la cual se realiza el lanzamiento del producto en el mercado objetivo identificado en las etapas iniciales \cite{DesignCouncil}.\\

Ahora que se puede definir de manera concisa el problema y a su vez el valor que se generará, es necesario centrarse en el modo en que será desarrollada la solución. En el desarrollo de software se identifican dos principales arquitecturas, la monolítica y la orientada a microservicios, esta primera consiste en un desarrollo centralizado donde todos los módulos y funcionalidades se encuentran en un mismo proyecto lo que a gran escala representa una aplicación robusta y segura, pero presenta un inconveniente al momento de abordar necesidades de escalabilidad, un ejemplo de esto es cuando se necesita escalar un modulo muy popular para los usuarios del sistema, esto implica a su vez escalar los módulos que no son tan populares lo que representa mayor consumo de recursos de los módulos que no los necesitan y, como los recursos suelen ser limitados, se limita también la capacidad de escalar. Otra característica de los sistemas monolíticos es que suelen ser desarrollados en una misma base de código con un mismo lenguaje lo que, aunque lo hace más comprensible por parte de los desarrolladores, obstruye el potencial que puede sacarse de otras herramientas, ademas, aumenta la complejidad en el caso de una posible migración \cite{Villamizar2015}.\\

Precisamente para solventar los inconvenientes de la arquitectura monolítica se plantea la arquitectura de microservicios, en la cual cada modulo del sistema es un proyecto a parte y por lo tanto posee sus propios datos, tecnologías, lenguajes o herramientas otorgando la posibilidad de que cada microservicio sea desplegado en un servidor a parte con propiedades específicas, así, si un modulo es mas popular para el usuario puede desplegarse en un servidor con más recursos que un servidor en el que se aloje un módulo menos popular. También, llegado el caso en el que se necesite agregar un nuevo modulo o funcionalidad solo se debe crear un nuevo microservicio y el desarrollo de este no afectara el funcionamiento de los demás.  Todos estos beneficios están sujetos a un proceso de despliegue  con una complejidad mas alta, el cual en la mayoría de los casos,  debido a la cantidad de microservicios creados, debe ser automatizado \cite{Netflix}.\\

En el cuadro 2 se presenta una tabla comparativa de las propiedades de la arquitectura monolítica y la arquitectura de microservicios \cite{Lopez2017}.

\begin{table}[ht]
\centering
\caption{Arquitectura monolítica vs microservicios}
\label{tabla2}
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{1}{|c|}{\textbf{Categoria}} & \multicolumn{1}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Arquitectura\\ monolítica\end{tabular}}}                                   & \multicolumn{1}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Arquitectura de\\ microservicios\end{tabular}}}                                                              \\ \hline
\textbf{Código}                          & \begin{tabular}[c]{@{}l@{}}Una base de código única\\ para toda la aplicación\end{tabular}                                        & \begin{tabular}[c]{@{}l@{}}Multiples bases de código.\\ Cada microservicio tiene su\\ propia base\end{tabular}                                                      \\ \hline
\textbf{Comprensibilidad}                & \begin{tabular}[c]{@{}l@{}}A menudo confuso y dificil\\ de mantener\end{tabular}                                                  & \begin{tabular}[c]{@{}l@{}}Mayor facilidad de lectura y \\ mucho más fácil de mantener\end{tabular}                                                                 \\ \hline
\textbf{Despliegue}                      & \begin{tabular}[c]{@{}l@{}}Implementaciones complejas con\\ ventanas de mantenimiento y \\ paradas de programas\end{tabular}      & \begin{tabular}[c]{@{}l@{}}Despliegue sencillo ya que cada\\ microservicio se puede implementar\\ de forma individual, tiempo de \\ inactividad minimo\end{tabular} \\ \hline
\textbf{Lenguaje}                        & \begin{tabular}[c]{@{}l@{}}Normalmente desarrollado en un\\ solo lenguaaje de programación\end{tabular}                           & \begin{tabular}[c]{@{}l@{}}Cada microservicio puede\\ desarrollarse en un lenguaje de \\ programación diferente\end{tabular}                                        \\ \hline
\textbf{Escalamiento}                    & \begin{tabular}[c]{@{}l@{}}Requiere escalar la aplicacion\\ entera aunque los cuellos de botella\\ esten localizados\end{tabular} & \begin{tabular}[c]{@{}l@{}}Puede escalarse un solo microservicio\\ en especifico sin necesidad de alterar\\ los demas\end{tabular}                                  \\ \hline
\end{tabular}
\end{table}

